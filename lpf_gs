#!/bin/sh

#
# Copyright (c) 2016 Aaron Poffenberger <akp@hypernote.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

#
# lpf_gs is an lpd(8) accounting filter that takes a PostScript, PDF
# or text file via stdin and converts it to an output format based on
# the calling name of the program using Ghostscript. Accouting
# information is logged to acct-name.
#
# See lpf_gs(1) for more details.
#

__basename="lpf_gs"
__progname=$(basename "$0")
__dirname=$(dirname "$0")
hostname=$(hostname -s)
pid=$$
err_exit=1
gs_device=$(basename "$__progname" '.if' | cut -d '_' -f 2)
log_msg() {
	msg="$*"
	if [ -z "$msg" ] ; then
		return 0
	fi
	if [ ! -t 0 ] ; then
		# sane date format but different from lpd
		# date=$(date "+%Y-%m-%d %H:%M:%S")

		# format date like lpd
		date=$(date "+%b %e %H:%M:%S")

		# send to stderr for logging
		# lpd will handle logging
		echo "$date $hostname $__progname[$pid]: ($job) $msg" >&2
	else
		# send to stdout to work with pipes
		# when users call from cl
		echo $msg
	fi
}

# create temp files
TMPFILE=`mktemp -q /tmp/lpf_${gs_device}.XXXXXXXXXX` ||
	(log_msg "Unable to create $__progname tmp file ... aborting" ; \
	 exit $err_exit)
ASERRFILE="${TMPFILE}.as_err"
ASTMPFILE="${TMPFILE}.as"
GSERRFILE="${TMPFILE}.gs_err"
GSTMPFILE="${TMPFILE}.gs"

cleanup() {
	trap "" EXIT
	rm -f "${TMPFILE}" "${ASERRFILE}" "${ASTMPFILE}" \
		"${GSERRFILE}" "${GSTMPFILE}"
}
trap cleanup EXIT
trap 'log_msg $__progname aborted by user;exit $err_exit' INT

TRUE=0
FALSE=1

# command line parameters that will be passed in from lpd
# printcap(5) FILTERS section
af=""		  # accounting file path
ctrl=$FALSE	  # whether to pass control characters literally
host="(null)"	  # sending host
indent=0	  # how much to indent
job="stdin"	  # job name
length=66	  # page length (default from lpf.c)
name=""		  # user who started job
width=132	  # page width (default from lpf.c)

# other variables
call="$0 $*"
cmd="print"	  # options: abort | print | usage | version
debug=$FALSE
as=$(which a2ps 2>/dev/null || which enscript 2>/dev/null)
gs=$(which gs 2>/dev/null)
version="1.0"
gs_init="${__dirname}/gs_init.ps"

# does the real work
print() {
	# send stdin to a file we can check format to see whether
	# we can print it
	cat > "${TMPFILE}"
	can_convert=$TRUE
	ft=$(file -b "${TMPFILE}")
	if echo "$ft" | grep -q text; then
		__as=$(basename "$as")
		if [  "$__as" = "a2ps" ] ; then
			log_msg Converting from ASCII to postscript \
				using $__as
			__header="-B --center-title='${job}'"
			$as -q -M letter $__header --output="${ASTMPFILE}" \
			    "${TMPFILE}" 2>"${ASERRFILE}"
			as_success=$?
		elif [ "$__as" = "enscript" ] ; then
			__header="${job} %W Page $% of $="
			log_msg Converting from ASCII to postscript \
				using $__as
			$as -q --header="$__header" --output="${ASTMPFILE}" \
			    "${TMPFILE}" 2>"${ASERRFILE}"
			as_success=$?
		else
			can_convert=$FALSE
			log_msg No ASCII converter found, abort conversion...
			exit $err_exit
		fi
		if [ $as_success -eq $FALSE ] ; then
			log_msg $(cat "${ASERRFILE}")
			exit $err_exit
		else
			mv "${ASTMPFILE}" "${GSTMPFILE}"
			mv_success=$?
			if [ $mv_success -eq $FALSE ] ; then
				log_msg Unable to mv "${ASTMPFILE}" "${GSTMPFILE}"
				exit $err_exit
			fi
		fi
	elif echo "$ft" | grep -Eq 'PDF|PostScript'; then
		log_msg Converting from PDF to $gs_device
		mv "${TMPFILE}" "${GSTMPFILE}"
		mv_success=$?
		if [ $mv_success -eq $FALSE ] ; then
			log_msg Unable to mv "${ASTMPFILE}" "${GSTMPFILE}"
			exit $err_exit
		fi
	else
		can_convert=$FALSE
		log_msg Unknown file type "($ft)", aborting conversion...
		exit $err_exit
	fi

	if [ $can_convert -eq $TRUE ] ; then
		# If there's a gs_init file prepend it to the processing queue.
		# gs fails if you leave an extra space from an empty variable.
		# Better to use an if/else to call gs correctly with/without
		# gs_init.ps
		if [ -e "${gs_init}" ] ; then
			$gs -q -dNOPROMPT -dNOPAUSE -dSAFER -dBATCH \
			    -dNOPAUSE -sDEVICE=${gs_device} -sOutputFile=- \
			    "${gs_init}" "${GSTMPFILE}" -c quit \
			    2>"${GSERRFILE}"
			gs_success=$?
		else
			$gs -q -dNOPROMPT -dNOPAUSE -dSAFER -dBATCH \
			    -dNOPAUSE -sDEVICE=${gs_device} -sOutputFile=- \
			    "${GSTMPFILE}" -c quit 2>"${GSERRFILE}"
			gs_success=$?
		fi
		if [ $gs_success -ne $TRUE ] ; then
			log_msg $(cat "${GSERRFILE}")
			exit $err_exit
		fi

		if [ ! -z "$af" ] ; then
			action="(${GSTMPFILE}) (r) file runpdfbegin pdfpagecount = quit"
			npages=$($gs -q -dNODISPLAY -c "$action" 2> "${GSERRFILE}")
			if [ $? -eq $TRUE ] ; then
				printf "%7.2f\\t%s:%s\\n" "$npages" "$host" "$name" \
				       >> $af
			else
				log_msg Print job completed but \
					unable to count pages for accounting file
				log_msg $(cat "${GSERRFILE}")
				log_msg This error often arises when converting \
					ASCII to postscript
			fi
		fi
	fi
}

version() {
	log_msg "$__basename $version - (linked as $__progname)"
}

usage() {
	# dispose of stdin data
	if [ ! -t 0 ] ; then
		cat > /dev/null
	fi
	version
	log_msg ""
	opts="[-c] [-h host] [-i indent] [-l length] [-n name] [-w width] [acctfile]"
	log_msg usage: $__progname $opts
	log_msg
}

debug() {
	if [ $debug -eq $TRUE -o ! -z "$LPF_GS_DEBUG" ] ; then
		log_msg Variables:
		log_msg $call
		log_msg device=$gs_device
		log_msg af=$af
		log_msg ctrl=$ctrl
		log_msg host=$host
		log_msg gs=$gs
		log_msg indent=$indent
		log_msg length=$length
		log_msg name=$name
		log_msg width=$width
		log_msg pid=$pid
		log_msg cmd=$cmd
		log_msg version=$version
		log_msg
	fi
}

if [ $__progname = $__basename ] ; then
	usage
	exit 0
fi

if [ ! -f "$gs" ] ; then
	log_msg "Ghostscript not installed."
	log_msg
	log_msg "Please install Ghostscript."
	exit $err_exit
fi

has_gs_device=$(gs -h | grep $gs_device | wc -l)
if [ $has_gs_device -eq 0 ] ; then
	version
	log_msg
	log_msg "No such ghostscript device '$gs_device' (cf gs -h)"
	log_msg
	log_msg "Execute 'gs -h' to see a list of supported devices."
	exit $err_exit
fi

if [ -z "$gs" ] ; then
	version
	log_msg
	log_msg "Unable to find ghostscript."
	exit $err_exit
fi

while getopts :cdh:i:j:l:n:vw: opt ; do
	case ${opt} in
		c)
			ctrl=$TRUE
			;;
		d)
			debug=$TRUE
			;;
		h)
			host=${OPTARG}
			;;
		i)
			indent=${OPTARG}
			;;
		j)
			job=${OPTARG}
			;;
		l)
			length=${OPTARG}
			;;
		n)
			name=${OPTARG}
			;;
		v)
			cmd="version"
			;;
		w)
			width=${OPTARG}
			;;
		:)
			log_msg $__progname: option requires an argument \
				-- ${OPTARG}
			log_msg
			cmd=abort
			;;
		\?)
			log_msg $__progname: invalid option -- ${OPTARG}
			log_msg
			cmd=abort
			;;
	esac
done
shift $(( OPTIND - 1 ))
# get remaining parameter as accounting file
af="$*"

case $cmd in
	print)
		print
		;;
	version)
		version
		;;
	usage)
		usage
		;;
	*)
		usage
		debug
		exit $err_exit
		;;
esac
debug
